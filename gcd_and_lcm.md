### GCD(最大公约数)
*复杂度log(min(a,b))*
```cpp
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;//辗转相除法
}
```
### LCM(最小公倍数)
```cpp
int lcm(int a, int b) {
    return a / gcd(a, b) * b;  // 先除后乘防止溢出
}
```

### 试除法求质因数
```cpp
/*核心在于：当代码尝试用一个合数 j 去整除 a 时，a 中所有构成 j 的更小的质因数，早已被除干净了。
让我们用一个例子来详细说明这个过程，比如要分解 a = 36：
初始化: a = 36, j = 2。
36 % 2 == 0 (成立)。进入内层 while 循环。
a 变成 18，记录下质因数 2 出现1次。
18 % 2 == 0 (成立)。
a 变成 9，更新质因数 2 的出现次数为2次。
9 % 2 == 0 (不成立)。内层循环结束。
此时，a 已经变成了 9。a 中所有的因子 2 都已经被彻底移除了。
j 递增到 3: a = 9。
9 % 3 == 0 (成立)。进入内层 while 循环。
a 变成 3，记录下质因数 3 出现1次。
3 % 3 == 0 (成立)。
a 变成 1，更新质因数 3 的出现次数为2次。
1 % 3 == 0 (不成立)。内层循环结束。
此时，a 变成了 1。
j 递增到 4 (关键点!): a = 1。
外层循环的条件 j * j <= a (即 4 * 4 <= 1) 已经不满足，循环会提前终止。
*/
        std::map<int, int> max_exponents;
        int a;
        cin >> a;

        // 对当前的数 a 进行质因数分解
        // 试除法，复杂度约为 O(sqrt(a))
        for (int j = 2; j * j <= a; ++j) {
            if (a % j == 0) {
                int count = 0;
                while (a % j == 0) {
                    a /= j;
                    count++;
                }
                // 更新质因数 j 的次幂
                max_exponents[j] = count;
            }
        }
        // 如果 a 分解后还有剩余（说明剩余部分是大于 sqrt(a) 的质数）
        if (a > 1) {
            // 这个质因数的次幂是 1
            max_exponents[a] = std::max(max_exponents[a], 1);
        }

```

## Tips
**任何一个大于1的自然数都可以唯一地分解成有限个质数的乘积。**

最小公倍数 (LCM) 的质因数分解性质：

一组数的最小公倍数，等于将这组数中每一个数进行质因数分解后，取所有出现过的质因数的最高次幂，然后将它们相乘。

**举个例子： 求 LCM(12, 18, 40)**

质因数分解:

12 = 2² × 3¹

18 = 2¹ × 3²

40 = 2³ × 5¹

找每个质因数的最高次幂:

对于质因数 2，最高次幂是 3 (来自40的 2³)。

对于质因数 3，最高次幂是 2 (来自18的 3²)。

对于质因数 5，最高次幂是 1 (来自40的 5¹)。

相乘得到LCM:

LCM = 2³ × 3² × 5¹ = 8 × 9 × 5 = 360
